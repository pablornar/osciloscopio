void INICIO(){
 //configuracion de clock
 
 REG_CKGR_PLLAR=(REG_CKGR_PLLAR & 0b11011111111111111111111100000000) | 0b00100000000000000000000000000001; //SE ESTABLECE EL DIV EN 1
 //REG_CKGR_PLLAR=(REG_CKGR_PLLAR & 0b11011111111111111100000011111111) | 0b00100000000000000010100000000000; //SE ESTABLECE EL PLLCOUNT EN 8 
 //REG_CKGR_PLLAR=(REG_CKGR_PLLAR & 0b11011000000000001111111111111111) | 0b00100000000101010100000000000000; //SE ESTABLECE EL MUL EN 21
 REG_CKGR_PLLAR=(REG_CKGR_PLLAR & 0b11011000000000001111111111111111) | 0b00100000000011010000000000000000; //SE ESTABLECE EL MUL EN 15
 REG_PMC_MCKR=(REG_PMC_MCKR & 0b11111111111111111111111111111100) | 0b00000000000000000000000000000010; //SELECCIONO EL CLOCK PLLA_CLK
 REG_PMC_MCKR=(REG_PMC_MCKR & 0b11111111111111111111111110001111) | 0b00000000000000000000000000010000; //SELECCIONO EL PREESCALER POR 2
 REG_PMC_MCKR=(REG_PMC_MCKR & 0b11111111111111111100111111111111) | 0b00000000000000000000000000000000; //SELECCIONO EL DIVISOR PLLA POR 2

 //CON ESTA CONFIGURACION NOS DA UNA FRECUENICA DE CLOCK DE (12MHZ/2)* 20 = 120MHZ
 //PARA 84MHZ COMO VIENE DE FABRICA SOLO SE DEBE COLOCAR EL MUL A 14 (1101) (12MHZ/2)* 14 = 84MHZ

 analogReadResolution(12);
 //para la adquisicion tengo un retardo de 1,25useg aproximadamemte con un reloj de 84Mhz
 //y de 0,95useg con un reloj de 120Mhz
 pmc_enable_periph_clk(ID_ADC);
//REG_ADC_MR = (REG_ADC_MR & 0b11000000111111111111111111111111) | 0b00000000000000000000000000000000; //tracking y transfer
 //REG_ADC_MR = (REG_ADC_MR & 0b11111111111111111111111110011111) | 0b00000000000000000000000000010000; //lowres 
 REG_ADC_MR = (REG_ADC_MR & 0b11111111111111111111111100011111) | 0b00000000000000000000000010000000; //habilita FREERUN mode
 REG_ADC_COR = (REG_ADC_COR & 0b11111111111111111111111111111111) | 0b00000000000000000000000000000000; //registro cor
 REG_ADC_CGR = (REG_ADC_CGR & 0b11111111111111111111111111111111) | 0b00000000000000000000000000000000; //Ganancia 7 A0
 REG_ADC_MR = (REG_ADC_MR & 0b11111111111100001111111111111111) | 0x00010000; // startup
 REG_ADC_MR = (REG_ADC_MR & 0b11111111110011111111111111111111) | 0x00000000; //Reduce los tiempos de conversion  Settling
 REG_ADC_MR = (REG_ADC_MR & 0b11111111111111110000000011111111) | 0x00000000;//preescaler a 16
 REG_ADC_MR = (REG_ADC_MR & 0b11110000111111111111111111111111) | 0x00000000; //tiempo de tracktim
 REG_ADC_MR = (REG_ADC_MR & 0b11001111111111111111111111111111) | 0x00000000; //tiempo de transfer
 REG_ADC_CHER = 0x00000080; //enable ADC on pin A0
 REG_ADC_CR = 0b00000000000000000000000000000010; //comienza la conversion
 
 //para la representacion en el dac tengo un retardo de 1,25useg aproximadamemte con un reloj de 84Mhz 
 //y de 0,95useg con un reloj de 120Mhz
 analogWriteResolution(12);
 analogWrite(DAC1,0);
 analogWrite(DAC0,0);
 
   
   /*//REG_DACC_CR=0x00000001;       //reseteo el dac
   //REG_DACC_IDR=0xffffffff;       //desabilito interrupciones
   REG_DACC_MR = (REG_DACC_MR & 0b11111111111111111111111111111111) | 0b00000000000000000000000000000000; //Trgen desabilitado
   REG_DACC_MR = (REG_DACC_MR & 0b11111111111111111111111111110001) | 0b00000000000000000000000000000010; //trgsel en 1
   REG_DACC_MR = (REG_DACC_MR & 0b11111111111111111111111111101111) | 0b00000000000000000000000000000000; //word en half 16 bits
   REG_DACC_MR = (REG_DACC_MR & 0b11111111111111111111111111011111) | 0b00000000000000000000000000000000; //sleep desabilitado
   REG_DACC_MR = (REG_DACC_MR & 0b11111111111111111111111110111111) | 0b00000000000000000000000000000000; //fastkkup en 0
   //REG_DACC_MR = (REG_DACC_MR & 0b11111111111111110000000011111111) | 0b00000000000000000001000000000000; //refresh en 8
   //REG_DACC_MR = (REG_DACC_MR & 0b11111111111111001111111111111111) | 0b00000000000000000000000000000000; //usersel canal 0
   REG_DACC_MR = (REG_DACC_MR & 0b11111111111011111111111111111111) | 0b00000000000000000000000000000000; //tag en 0
   REG_DACC_MR = (REG_DACC_MR & 0b11111111110111111111111111111111) | 0b00000000001000000000000000000000; //modo maxs en fast
   REG_DACC_MR = (REG_DACC_MR & 0b11000000111111111111111111111111) | 0b00001000000000000000000000000000; //startup en 8
    */
  
 REG_DACC_MR = (REG_DACC_MR & 0b00000000111111111111111111111111) | 0b00000000100000000000000000000000;//dac starup en 2 ciclos de reloj
 REG_DACC_MR = (REG_DACC_MR & 0b11111111110111111111111111111111) | 0b00000000001000000000000000000000;//dac en maxima velocidad
 REG_DACC_MR = (REG_DACC_MR & 0b11111111111111111111111111101111) | 0b00000000000000000000000000000000;//dac en modo de 15 bits
 //REG_DACC_MR = (REG_DACC_MR & 0b11111111111111110000000011111111) | 0b00000000000000000000000100000000;//dac para el refresco de datos
 //REG_DACC_MR = (REG_DACC_MR & 0b11111111111111001111111111111111) | 0b00000000000000000000000000000000;//dac user sel en canal 0
 //REG_DACC_MR = (REG_DACC_MR & 0b11111111111111001111111111111111) | 0b00000000000000010000000000000000;//dac user sel en canal 1
 //REG_DACC_WPMR=  0x00000000;
 //REG_DACC_CHER = 0x00000001; //enable DAC on pin A0

// configuracion de TC

  pmc_enable_periph_clk(ID_TC0);    //habilita el clock para el timer counter TC0
  REG_TC0_CCR0=0b00000000000000000000000000000010;    // desabilito clldis
  //REG_TC0_IDR0=0xffffffff;        //desabilito interrupciones
  REG_TC0_CMR0 = (REG_TC0_CMR0 & 0b11111111111111110111111111111111) | 0b00000000000000001000000000000000; //wave en 1
  REG_TC0_CMR0 = (REG_TC0_CMR0 & 0b11111111111111111111111111111000) | 0b00000000000000000000000000000000; //tccclocks en 0
  REG_TC0_CMR0 = (REG_TC0_CMR0 & 0b11111111111111001111111111111111) | 0b00000000000000100000000000000000; //acpa en 2 clear
  REG_TC0_CMR0 = (REG_TC0_CMR0 & 0b11111111111111111001111111111111) | 0b00000000000000000100000000000000; //wsel en 2 uprc
  REG_TC0_IER0 = (REG_TC0_IER0 & 0b11111111111111111111111111101111) | 0b00000000000000000000000000010000; //habilito interrupcion por cpcs
  NVIC_EnableIRQ(TC0_IRQn);  //habilita las interrupciones del tc
  REG_TC0_RC0=(Tretint);  //carga el registro A con el valor a comparar
  //REG_TC0_CCR0=0b00000000000000000000000000000101;    // start counter


 
   
     REG_DACC_MR = (REG_DACC_MR & 0b11111111111111001111111111111111) | 0b0000000000000010000000000000000;//dac user sel en canal 1
     REG_DACC_CHER=0b0000000000000000000000000000010;
     while ((REG_DACC_ISR & 0b00000000000000000000000000000001)== 0); //espera que el registro este disponible para una conversion
     REG_DACC_CDR = (0);//escribe el DAC con el valor del registro pwm

    
    REG_DACC_MR = (REG_DACC_MR & 0b11111111111111001111111111111111) | 0b0000000000000000000000000000000;//dac user sel en canal 0
    REG_DACC_CHER=0b0000000000000000000000000000001;
    while ((REG_DACC_ISR & 0b00000000000000000000000000000001)== 0); //espera que el registro este disponible para una conversion
    REG_DACC_CDR = (0);//escribe el DAC con el valor del registro pwm
    
 myGLCD.InitLCD(LANDSCAPE); //apaga lcd
 myGLCD.clrScr(); //borra pantalla
 myGLCD.setFont(BigFont); //configura letra pantalla
 myTouch.InitTouch();
 myTouch.setPrecision(PREC_HI); //para establecer la precision de la presion en el boton
 myButtons.setTextFont(BigFont); //configura letra de botones
  
}
